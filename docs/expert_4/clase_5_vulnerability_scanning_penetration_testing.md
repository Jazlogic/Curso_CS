# 游댌 **Clase 5: Vulnerability Scanning y Penetration Testing**

## 游꿢 **Objetivo de la Clase**
Dominar las t칠cnicas de identificaci칩n de vulnerabilidades, herramientas de scanning y metodolog칤as de penetration testing para aplicaciones .NET.

## 游닄 **Contenido de la Clase**

### **1. Vulnerability Scanning**

#### **1.1 Static Application Security Testing (SAST)**
```csharp
// Implementaci칩n de SAST personalizado
public class StaticSecurityAnalyzer
{
    private readonly ILogger<StaticSecurityAnalyzer> _logger;
    private readonly List<ISecurityRule> _securityRules;
    
    public StaticSecurityAnalyzer(ILogger<StaticSecurityAnalyzer> logger)
    {
        _logger = logger;
        _securityRules = new List<ISecurityRule>
        {
            new SqlInjectionRule(),
            new XssRule(),
            new HardcodedPasswordRule(),
            new WeakEncryptionRule(),
            new InsecureDeserializationRule(),
            new PathTraversalRule()
        };
    }
    
    // Analizar archivo de c칩digo fuente
    public async Task<SecurityAnalysisResult> AnalyzeFileAsync(string filePath)
    {
        try
        {
            var result = new SecurityAnalysisResult
            {
                FilePath = filePath,
                Vulnerabilities = new List<SecurityVulnerability>()
            };
            
            var sourceCode = await File.ReadAllTextAsync(filePath);
            var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
            var root = syntaxTree.GetRoot();
            
            // Analizar con cada regla de seguridad
            foreach (var rule in _securityRules)
            {
                var vulnerabilities = await rule.AnalyzeAsync(syntaxTree, root);
                result.Vulnerabilities.AddRange(vulnerabilities);
            }
            
            result.Severity = CalculateOverallSeverity(result.Vulnerabilities);
            
            _logger.LogInformation("Security analysis completed for {FilePath}: {VulnerabilityCount} vulnerabilities found", 
                filePath, result.Vulnerabilities.Count);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error analyzing file: {FilePath}", filePath);
            throw;
        }
    }
    
    // Analizar proyecto completo
    public async Task<ProjectSecurityAnalysisResult> AnalyzeProjectAsync(string projectPath)
    {
        try
        {
            var result = new ProjectSecurityAnalysisResult
            {
                ProjectPath = projectPath,
                FileResults = new List<SecurityAnalysisResult>(),
                Summary = new SecuritySummary()
            };
            
            var sourceFiles = Directory.GetFiles(projectPath, "*.cs", SearchOption.AllDirectories);
            
            foreach (var file in sourceFiles)
            {
                var fileResult = await AnalyzeFileAsync(file);
                result.FileResults.Add(fileResult);
            }
            
            // Calcular resumen del proyecto
            result.Summary = CalculateProjectSummary(result.FileResults);
            
            _logger.LogInformation("Project security analysis completed: {TotalVulnerabilities} vulnerabilities found", 
                result.Summary.TotalVulnerabilities);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error analyzing project: {ProjectPath}", projectPath);
            throw;
        }
    }
    
    private SecuritySeverity CalculateOverallSeverity(List<SecurityVulnerability> vulnerabilities)
    {
        if (vulnerabilities.Any(v => v.Severity == SecuritySeverity.Critical))
            return SecuritySeverity.Critical;
        
        if (vulnerabilities.Any(v => v.Severity == SecuritySeverity.High))
            return SecuritySeverity.High;
        
        if (vulnerabilities.Any(v => v.Severity == SecuritySeverity.Medium))
            return SecuritySeverity.Medium;
        
        if (vulnerabilities.Any(v => v.Severity == SecuritySeverity.Low))
            return SecuritySeverity.Low;
        
        return SecuritySeverity.Info;
    }
    
    private SecuritySummary CalculateProjectSummary(List<SecurityAnalysisResult> fileResults)
    {
        var summary = new SecuritySummary();
        
        foreach (var fileResult in fileResults)
        {
            summary.TotalFiles++;
            summary.TotalVulnerabilities += fileResult.Vulnerabilities.Count;
            
            foreach (var vulnerability in fileResult.Vulnerabilities)
            {
                switch (vulnerability.Severity)
                {
                    case SecuritySeverity.Critical:
                        summary.CriticalCount++;
                        break;
                    case SecuritySeverity.High:
                        summary.HighCount++;
                        break;
                    case SecuritySeverity.Medium:
                        summary.MediumCount++;
                        break;
                    case SecuritySeverity.Low:
                        summary.LowCount++;
                        break;
                    case SecuritySeverity.Info:
                        summary.InfoCount++;
                        break;
                }
            }
        }
        
        return summary;
    }
}

// Interfaz para reglas de seguridad
public interface ISecurityRule
{
    Task<List<SecurityVulnerability>> AnalyzeAsync(SyntaxTree syntaxTree, SyntaxNode root);
}

// Regla para detectar SQL Injection
public class SqlInjectionRule : ISecurityRule
{
    public async Task<List<SecurityVulnerability>> AnalyzeAsync(SyntaxTree syntaxTree, SyntaxNode root)
    {
        var vulnerabilities = new List<SecurityVulnerability>();
        
        // Buscar concatenaci칩n de strings en consultas SQL
        var stringConcatenations = root.DescendantNodes()
            .OfType<BinaryExpressionSyntax>()
            .Where(expr => expr.OperatorToken.IsKind(SyntaxKind.PlusToken))
            .Where(expr => IsSqlQuery(expr));
        
        foreach (var concat in stringConcatenations)
        {
            vulnerabilities.Add(new SecurityVulnerability
            {
                Type = "SQL Injection",
                Severity = SecuritySeverity.High,
                Description = "Potential SQL injection vulnerability detected",
                LineNumber = concat.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
                CodeSnippet = concat.ToString(),
                Recommendation = "Use parameterized queries or Entity Framework"
            });
        }
        
        return vulnerabilities;
    }
    
    private bool IsSqlQuery(BinaryExpressionSyntax expression)
    {
        var text = expression.ToString().ToLower();
        return text.Contains("select") || text.Contains("insert") || 
               text.Contains("update") || text.Contains("delete");
    }
}

// Regla para detectar XSS
public class XssRule : ISecurityRule
{
    public async Task<List<SecurityVulnerability>> AnalyzeAsync(SyntaxTree syntaxTree, SyntaxNode root)
    {
        var vulnerabilities = new List<SecurityVulnerability>();
        
        // Buscar uso de Html.Raw sin sanitizaci칩n
        var htmlRawCalls = root.DescendantNodes()
            .OfType<InvocationExpressionSyntax>()
            .Where(inv => inv.Expression.ToString().Contains("Html.Raw"));
        
        foreach (var call in htmlRawCalls)
        {
            vulnerabilities.Add(new SecurityVulnerability
            {
                Type = "Cross-Site Scripting (XSS)",
                Severity = SecuritySeverity.High,
                Description = "Potential XSS vulnerability - Html.Raw used without sanitization",
                LineNumber = call.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
                CodeSnippet = call.ToString(),
                Recommendation = "Use Html.Encode or sanitize input before using Html.Raw"
            });
        }
        
        return vulnerabilities;
    }
}

// Regla para detectar contrase침as hardcodeadas
public class HardcodedPasswordRule : ISecurityRule
{
    public async Task<List<SecurityVulnerability>> AnalyzeAsync(SyntaxTree syntaxTree, SyntaxNode root)
    {
        var vulnerabilities = new List<SecurityVulnerability>();
        
        // Buscar strings que parecen contrase침as
        var stringLiterals = root.DescendantNodes()
            .OfType<LiteralExpressionSyntax>()
            .Where(lit => lit.IsKind(SyntaxKind.StringLiteralExpression));
        
        foreach (var literal in stringLiterals)
        {
            var value = literal.Token.ValueText;
            if (IsPasswordLike(value))
            {
                vulnerabilities.Add(new SecurityVulnerability
                {
                    Type = "Hardcoded Password",
                    Severity = SecuritySeverity.Critical,
                    Description = "Hardcoded password detected",
                    LineNumber = literal.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
                    CodeSnippet = literal.ToString(),
                    Recommendation = "Use configuration or secure key management"
                });
            }
        }
        
        return vulnerabilities;
    }
    
    private bool IsPasswordLike(string value)
    {
        // Patrones comunes de contrase침as hardcodeadas
        var patterns = new[]
        {
            "password", "pass", "pwd", "secret", "key", "token",
            "admin", "root", "user", "guest"
        };
        
        return patterns.Any(pattern => value.ToLower().Contains(pattern)) && value.Length > 3;
    }
}

// Modelos para an치lisis de seguridad
public class SecurityAnalysisResult
{
    public string FilePath { get; set; }
    public List<SecurityVulnerability> Vulnerabilities { get; set; }
    public SecuritySeverity Severity { get; set; }
}

public class ProjectSecurityAnalysisResult
{
    public string ProjectPath { get; set; }
    public List<SecurityAnalysisResult> FileResults { get; set; }
    public SecuritySummary Summary { get; set; }
}

public class SecurityVulnerability
{
    public string Type { get; set; }
    public SecuritySeverity Severity { get; set; }
    public string Description { get; set; }
    public int LineNumber { get; set; }
    public string CodeSnippet { get; set; }
    public string Recommendation { get; set; }
}

public class SecuritySummary
{
    public int TotalFiles { get; set; }
    public int TotalVulnerabilities { get; set; }
    public int CriticalCount { get; set; }
    public int HighCount { get; set; }
    public int MediumCount { get; set; }
    public int LowCount { get; set; }
    public int InfoCount { get; set; }
}

public enum SecuritySeverity
{
    Info,
    Low,
    Medium,
    High,
    Critical
}
```

#### **1.2 Dynamic Application Security Testing (DAST)**
```csharp
// Implementaci칩n de DAST personalizado
public class DynamicSecurityTester
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<DynamicSecurityTester> _logger;
    private readonly List<ISecurityTest> _securityTests;
    
    public DynamicSecurityTester(HttpClient httpClient, ILogger<DynamicSecurityTester> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _securityTests = new List<ISecurityTest>
        {
            new SqlInjectionTest(),
            new XssTest(),
            new CsrfTest(),
            new AuthenticationBypassTest(),
            new AuthorizationTest(),
            new InputValidationTest()
        };
    }
    
    // Ejecutar pruebas de seguridad din치micas
    public async Task<DynamicSecurityTestResult> RunSecurityTestsAsync(string baseUrl)
    {
        try
        {
            var result = new DynamicSecurityTestResult
            {
                BaseUrl = baseUrl,
                TestResults = new List<SecurityTestResult>(),
                StartTime = DateTime.UtcNow
            };
            
            // Descubrir endpoints
            var endpoints = await DiscoverEndpointsAsync(baseUrl);
            
            // Ejecutar pruebas en cada endpoint
            foreach (var endpoint in endpoints)
            {
                foreach (var test in _securityTests)
                {
                    var testResult = await test.ExecuteAsync(endpoint, _httpClient);
                    result.TestResults.Add(testResult);
                }
            }
            
            result.EndTime = DateTime.UtcNow;
            result.Duration = result.EndTime - result.StartTime;
            result.Summary = CalculateTestSummary(result.TestResults);
            
            _logger.LogInformation("Dynamic security tests completed: {VulnerabilityCount} vulnerabilities found", 
                result.Summary.TotalVulnerabilities);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error running dynamic security tests");
            throw;
        }
    }
    
    // Descubrir endpoints de la aplicaci칩n
    private async Task<List<Endpoint>> DiscoverEndpointsAsync(string baseUrl)
    {
        var endpoints = new List<Endpoint>();
        
        try
        {
            // Obtener robots.txt
            var robotsResponse = await _httpClient.GetAsync($"{baseUrl}/robots.txt");
            if (robotsResponse.IsSuccessStatusCode)
            {
                var robotsContent = await robotsResponse.Content.ReadAsStringAsync();
                var robotsEndpoints = ParseRobotsTxt(robotsContent);
                endpoints.AddRange(robotsEndpoints);
            }
            
            // Obtener sitemap.xml
            var sitemapResponse = await _httpClient.GetAsync($"{baseUrl}/sitemap.xml");
            if (sitemapResponse.IsSuccessStatusCode)
            {
                var sitemapContent = await sitemapResponse.Content.ReadAsStringAsync();
                var sitemapEndpoints = ParseSitemapXml(sitemapContent);
                endpoints.AddRange(sitemapEndpoints);
            }
            
            // Endpoints comunes
            var commonEndpoints = new[]
            {
                "/", "/login", "/register", "/admin", "/api", "/api/users",
                "/api/products", "/api/orders", "/search", "/profile"
            };
            
            foreach (var endpoint in commonEndpoints)
            {
                endpoints.Add(new Endpoint
                {
                    Url = $"{baseUrl}{endpoint}",
                    Method = "GET",
                    Parameters = new Dictionary<string, string>()
                });
            }
            
            _logger.LogInformation("Discovered {Count} endpoints", endpoints.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error discovering endpoints");
        }
        
        return endpoints;
    }
    
    private List<Endpoint> ParseRobotsTxt(string content)
    {
        var endpoints = new List<Endpoint>();
        var lines = content.Split('\n');
        
        foreach (var line in lines)
        {
            if (line.StartsWith("Disallow:") || line.StartsWith("Allow:"))
            {
                var path = line.Split(':')[1].Trim();
                if (!string.IsNullOrEmpty(path) && path != "/")
                {
                    endpoints.Add(new Endpoint
                    {
                        Url = path,
                        Method = "GET",
                        Parameters = new Dictionary<string, string>()
                    });
                }
            }
        }
        
        return endpoints;
    }
    
    private List<Endpoint> ParseSitemapXml(string content)
    {
        var endpoints = new List<Endpoint>();
        
        try
        {
            var doc = XDocument.Parse(content);
            var urls = doc.Descendants("url").Select(u => u.Element("loc")?.Value);
            
            foreach (var url in urls)
            {
                if (!string.IsNullOrEmpty(url))
                {
                    endpoints.Add(new Endpoint
                    {
                        Url = url,
                        Method = "GET",
                        Parameters = new Dictionary<string, string>()
                    });
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing sitemap.xml");
        }
        
        return endpoints;
    }
    
    private TestSummary CalculateTestSummary(List<SecurityTestResult> testResults)
    {
        var summary = new TestSummary
        {
            TotalTests = testResults.Count,
            TotalVulnerabilities = testResults.Count(r => r.IsVulnerable),
            CriticalCount = testResults.Count(r => r.Severity == SecuritySeverity.Critical),
            HighCount = testResults.Count(r => r.Severity == SecuritySeverity.High),
            MediumCount = testResults.Count(r => r.Severity == SecuritySeverity.Medium),
            LowCount = testResults.Count(r => r.Severity == SecuritySeverity.Low)
        };
        
        return summary;
    }
}

// Interfaz para pruebas de seguridad
public interface ISecurityTest
{
    Task<SecurityTestResult> ExecuteAsync(Endpoint endpoint, HttpClient httpClient);
}

// Prueba de SQL Injection
public class SqlInjectionTest : ISecurityTest
{
    public async Task<SecurityTestResult> ExecuteAsync(Endpoint endpoint, HttpClient httpClient)
    {
        var result = new SecurityTestResult
        {
            TestName = "SQL Injection Test",
            Endpoint = endpoint.Url,
            Method = endpoint.Method
        };
        
        try
        {
            // Payloads de SQL Injection
            var payloads = new[]
            {
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users --",
                "1' OR 1=1 --",
                "admin'--"
            };
            
            foreach (var payload in payloads)
            {
                var testUrl = $"{endpoint.Url}?id={payload}";
                var response = await httpClient.GetAsync(testUrl);
                
                if (response.IsSuccessStatusCode)
                {
                    var content = await response.Content.ReadAsStringAsync();
                    
                    // Verificar indicadores de SQL Injection
                    if (IsSqlInjectionDetected(content))
                    {
                        result.IsVulnerable = true;
                        result.Severity = SecuritySeverity.High;
                        result.Description = "SQL Injection vulnerability detected";
                        result.Payload = payload;
                        result.Response = content;
                        break;
                    }
                }
            }
            
            if (!result.IsVulnerable)
            {
                result.Severity = SecuritySeverity.Info;
                result.Description = "No SQL Injection vulnerability detected";
            }
        }
        catch (Exception ex)
        {
            result.IsVulnerable = false;
            result.Description = $"Test failed: {ex.Message}";
        }
        
        return result;
    }
    
    private bool IsSqlInjectionDetected(string response)
    {
        var indicators = new[]
        {
            "sql syntax", "mysql", "postgresql", "sqlite", "oracle",
            "sql server", "database error", "sql error", "query failed"
        };
        
        return indicators.Any(indicator => 
            response.ToLower().Contains(indicator));
    }
}

// Prueba de XSS
public class XssTest : ISecurityTest
{
    public async Task<SecurityTestResult> ExecuteAsync(Endpoint endpoint, HttpClient httpClient)
    {
        var result = new SecurityTestResult
        {
            TestName = "XSS Test",
            Endpoint = endpoint.Url,
            Method = endpoint.Method
        };
        
        try
        {
            // Payloads de XSS
            var payloads = new[]
            {
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "';alert('XSS');//"
            };
            
            foreach (var payload in payloads)
            {
                var testUrl = $"{endpoint.Url}?search={payload}";
                var response = await httpClient.GetAsync(testUrl);
                
                if (response.IsSuccessStatusCode)
                {
                    var content = await response.Content.ReadAsStringAsync();
                    
                    // Verificar si el payload est치 reflejado sin sanitizaci칩n
                    if (content.Contains(payload))
                    {
                        result.IsVulnerable = true;
                        result.Severity = SecuritySeverity.High;
                        result.Description = "XSS vulnerability detected";
                        result.Payload = payload;
                        result.Response = content;
                        break;
                    }
                }
            }
            
            if (!result.IsVulnerable)
            {
                result.Severity = SecuritySeverity.Info;
                result.Description = "No XSS vulnerability detected";
            }
        }
        catch (Exception ex)
        {
            result.IsVulnerable = false;
            result.Description = $"Test failed: {ex.Message}";
        }
        
        return result;
    }
}

// Modelos para pruebas din치micas
public class Endpoint
{
    public string Url { get; set; }
    public string Method { get; set; }
    public Dictionary<string, string> Parameters { get; set; }
}

public class DynamicSecurityTestResult
{
    public string BaseUrl { get; set; }
    public List<SecurityTestResult> TestResults { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public TimeSpan Duration { get; set; }
    public TestSummary Summary { get; set; }
}

public class SecurityTestResult
{
    public string TestName { get; set; }
    public string Endpoint { get; set; }
    public string Method { get; set; }
    public bool IsVulnerable { get; set; }
    public SecuritySeverity Severity { get; set; }
    public string Description { get; set; }
    public string Payload { get; set; }
    public string Response { get; set; }
}

public class TestSummary
{
    public int TotalTests { get; set; }
    public int TotalVulnerabilities { get; set; }
    public int CriticalCount { get; set; }
    public int HighCount { get; set; }
    public int MediumCount { get; set; }
    public int LowCount { get; set; }
}
```

### **2. Penetration Testing**

#### **2.1 Automated Penetration Testing**
```csharp
// Servicio de penetration testing automatizado
public class AutomatedPenetrationTester
{
    private readonly ILogger<AutomatedPenetrationTester> _logger;
    private readonly List<IPenetrationTest> _penetrationTests;
    
    public AutomatedPenetrationTester(ILogger<AutomatedPenetrationTester> logger)
    {
        _logger = logger;
        _penetrationTests = new List<IPenetrationTest>
        {
            new AuthenticationBypassTest(),
            new PrivilegeEscalationTest(),
            new SessionManagementTest(),
            new InputValidationTest(),
            new BusinessLogicTest(),
            new InfrastructureTest()
        };
    }
    
    // Ejecutar penetration testing completo
    public async Task<PenetrationTestResult> RunPenetrationTestsAsync(string targetUrl)
    {
        try
        {
            var result = new PenetrationTestResult
            {
                TargetUrl = targetUrl,
                TestResults = new List<PenetrationTestResultItem>(),
                StartTime = DateTime.UtcNow
            };
            
            // Ejecutar cada prueba de penetraci칩n
            foreach (var test in _penetrationTests)
            {
                var testResult = await test.ExecuteAsync(targetUrl);
                result.TestResults.Add(testResult);
            }
            
            result.EndTime = DateTime.UtcNow;
            result.Duration = result.EndTime - result.StartTime;
            result.Summary = CalculatePenetrationTestSummary(result.TestResults);
            
            _logger.LogInformation("Penetration testing completed: {VulnerabilityCount} vulnerabilities found", 
                result.Summary.TotalVulnerabilities);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error running penetration tests");
            throw;
        }
    }
    
    private PenetrationTestSummary CalculatePenetrationTestSummary(List<PenetrationTestResultItem> testResults)
    {
        var summary = new PenetrationTestSummary
        {
            TotalTests = testResults.Count,
            TotalVulnerabilities = testResults.Count(r => r.IsVulnerable),
            CriticalCount = testResults.Count(r => r.Severity == SecuritySeverity.Critical),
            HighCount = testResults.Count(r => r.Severity == SecuritySeverity.High),
            MediumCount = testResults.Count(r => r.Severity == SecuritySeverity.Medium),
            LowCount = testResults.Count(r => r.Severity == SecuritySeverity.Low)
        };
        
        return summary;
    }
}

// Interfaz para pruebas de penetraci칩n
public interface IPenetrationTest
{
    Task<PenetrationTestResultItem> ExecuteAsync(string targetUrl);
}

// Prueba de bypass de autenticaci칩n
public class AuthenticationBypassTest : IPenetrationTest
{
    public async Task<PenetrationTestResultItem> ExecuteAsync(string targetUrl)
    {
        var result = new PenetrationTestResultItem
        {
            TestName = "Authentication Bypass Test",
            TargetUrl = targetUrl
        };
        
        try
        {
            using var httpClient = new HttpClient();
            
            // Intentar acceder a endpoints protegidos sin autenticaci칩n
            var protectedEndpoints = new[]
            {
                "/admin", "/api/admin", "/dashboard", "/profile",
                "/api/users", "/api/orders", "/api/products"
            };
            
            foreach (var endpoint in protectedEndpoints)
            {
                var url = $"{targetUrl}{endpoint}";
                var response = await httpClient.GetAsync(url);
                
                if (response.IsSuccessStatusCode)
                {
                    var content = await response.Content.ReadAsStringAsync();
                    
                    // Verificar si se accedi칩 sin autenticaci칩n
                    if (!content.Contains("login") && !content.Contains("unauthorized"))
                    {
                        result.IsVulnerable = true;
                        result.Severity = SecuritySeverity.Critical;
                        result.Description = $"Authentication bypass detected at {endpoint}";
                        result.Evidence = content;
                        break;
                    }
                }
            }
            
            if (!result.IsVulnerable)
            {
                result.Severity = SecuritySeverity.Info;
                result.Description = "No authentication bypass vulnerability detected";
            }
        }
        catch (Exception ex)
        {
            result.IsVulnerable = false;
            result.Description = $"Test failed: {ex.Message}";
        }
        
        return result;
    }
}

// Prueba de escalaci칩n de privilegios
public class PrivilegeEscalationTest : IPenetrationTest
{
    public async Task<PenetrationTestResultItem> ExecuteAsync(string targetUrl)
    {
        var result = new PenetrationTestResultItem
        {
            TestName = "Privilege Escalation Test",
            TargetUrl = targetUrl
        };
        
        try
        {
            using var httpClient = new HttpClient();
            
            // Simular usuario con privilegios bajos
            var lowPrivilegeUser = new
            {
                Username = "user",
                Password = "password",
                Role = "user"
            };
            
            // Intentar acceder a funcionalidades de administrador
            var adminEndpoints = new[]
            {
                "/admin/users", "/admin/settings", "/admin/logs",
                "/api/admin/users", "/api/admin/settings"
            };
            
            foreach (var endpoint in adminEndpoints)
            {
                var url = $"{targetUrl}{endpoint}";
                var response = await httpClient.GetAsync(url);
                
                if (response.IsSuccessStatusCode)
                {
                    var content = await response.Content.ReadAsStringAsync();
                    
                    // Verificar si se accedi칩 con privilegios insuficientes
                    if (content.Contains("admin") || content.Contains("settings"))
                    {
                        result.IsVulnerable = true;
                        result.Severity = SecuritySeverity.High;
                        result.Description = $"Privilege escalation detected at {endpoint}";
                        result.Evidence = content;
                        break;
                    }
                }
            }
            
            if (!result.IsVulnerable)
            {
                result.Severity = SecuritySeverity.Info;
                result.Description = "No privilege escalation vulnerability detected";
            }
        }
        catch (Exception ex)
        {
            result.IsVulnerable = false;
            result.Description = $"Test failed: {ex.Message}";
        }
        
        return result;
    }
}

// Modelos para penetration testing
public class PenetrationTestResult
{
    public string TargetUrl { get; set; }
    public List<PenetrationTestResultItem> TestResults { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public TimeSpan Duration { get; set; }
    public PenetrationTestSummary Summary { get; set; }
}

public class PenetrationTestResultItem
{
    public string TestName { get; set; }
    public string TargetUrl { get; set; }
    public bool IsVulnerable { get; set; }
    public SecuritySeverity Severity { get; set; }
    public string Description { get; set; }
    public string Evidence { get; set; }
    public string Recommendation { get; set; }
}

public class PenetrationTestSummary
{
    public int TotalTests { get; set; }
    public int TotalVulnerabilities { get; set; }
    public int CriticalCount { get; set; }
    public int HighCount { get; set; }
    public int MediumCount { get; set; }
    public int LowCount { get; set; }
}
```

#### **2.2 Vulnerability Reporting**
```csharp
// Servicio de generaci칩n de reportes de vulnerabilidades
public class VulnerabilityReportingService
{
    private readonly ILogger<VulnerabilityReportingService> _logger;
    
    public VulnerabilityReportingService(ILogger<VulnerabilityReportingService> logger)
    {
        _logger = logger;
    }
    
    // Generar reporte de vulnerabilidades
    public async Task<string> GenerateVulnerabilityReportAsync(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        try
        {
            var report = new VulnerabilityReport
            {
                GeneratedAt = DateTime.UtcNow,
                StaticAnalysis = staticAnalysis,
                DynamicAnalysis = dynamicAnalysis,
                PenetrationTest = penetrationTest,
                ExecutiveSummary = GenerateExecutiveSummary(staticAnalysis, dynamicAnalysis, penetrationTest),
                Recommendations = GenerateRecommendations(staticAnalysis, dynamicAnalysis, penetrationTest)
            };
            
            var reportJson = JsonSerializer.Serialize(report, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            
            _logger.LogInformation("Vulnerability report generated successfully");
            
            return reportJson;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating vulnerability report");
            throw;
        }
    }
    
    // Generar reporte en formato HTML
    public async Task<string> GenerateHtmlReportAsync(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        try
        {
            var html = new StringBuilder();
            
            html.AppendLine("<!DOCTYPE html>");
            html.AppendLine("<html>");
            html.AppendLine("<head>");
            html.AppendLine("<title>Security Vulnerability Report</title>");
            html.AppendLine("<style>");
            html.AppendLine(GetReportStyles());
            html.AppendLine("</style>");
            html.AppendLine("</head>");
            html.AppendLine("<body>");
            
            // Header
            html.AppendLine("<header>");
            html.AppendLine("<h1>Security Vulnerability Report</h1>");
            html.AppendLine($"<p>Generated on: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}</p>");
            html.AppendLine("</header>");
            
            // Executive Summary
            html.AppendLine("<section class='executive-summary'>");
            html.AppendLine("<h2>Executive Summary</h2>");
            html.AppendLine(GenerateExecutiveSummaryHtml(staticAnalysis, dynamicAnalysis, penetrationTest));
            html.AppendLine("</section>");
            
            // Static Analysis Results
            html.AppendLine("<section class='static-analysis'>");
            html.AppendLine("<h2>Static Analysis Results</h2>");
            html.AppendLine(GenerateStaticAnalysisHtml(staticAnalysis));
            html.AppendLine("</section>");
            
            // Dynamic Analysis Results
            html.AppendLine("<section class='dynamic-analysis'>");
            html.AppendLine("<h2>Dynamic Analysis Results</h2>");
            html.AppendLine(GenerateDynamicAnalysisHtml(dynamicAnalysis));
            html.AppendLine("</section>");
            
            // Penetration Test Results
            html.AppendLine("<section class='penetration-test'>");
            html.AppendLine("<h2>Penetration Test Results</h2>");
            html.AppendLine(GeneratePenetrationTestHtml(penetrationTest));
            html.AppendLine("</section>");
            
            // Recommendations
            html.AppendLine("<section class='recommendations'>");
            html.AppendLine("<h2>Recommendations</h2>");
            html.AppendLine(GenerateRecommendationsHtml(staticAnalysis, dynamicAnalysis, penetrationTest));
            html.AppendLine("</section>");
            
            html.AppendLine("</body>");
            html.AppendLine("</html>");
            
            _logger.LogInformation("HTML vulnerability report generated successfully");
            
            return html.ToString();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating HTML vulnerability report");
            throw;
        }
    }
    
    private string GenerateExecutiveSummary(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        var totalVulnerabilities = staticAnalysis.Summary.TotalVulnerabilities +
                                 dynamicAnalysis.Summary.TotalVulnerabilities +
                                 penetrationTest.Summary.TotalVulnerabilities;
        
        var criticalCount = staticAnalysis.Summary.CriticalCount +
                          dynamicAnalysis.Summary.CriticalCount +
                          penetrationTest.Summary.CriticalCount;
        
        var highCount = staticAnalysis.Summary.HighCount +
                       dynamicAnalysis.Summary.HighCount +
                       penetrationTest.Summary.HighCount;
        
        return $"Total vulnerabilities found: {totalVulnerabilities}. " +
               $"Critical: {criticalCount}, High: {highCount}. " +
               "Immediate action required for critical and high severity issues.";
    }
    
    private string GenerateRecommendations(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        var recommendations = new List<string>();
        
        if (staticAnalysis.Summary.CriticalCount > 0)
        {
            recommendations.Add("Address critical static analysis findings immediately");
        }
        
        if (dynamicAnalysis.Summary.CriticalCount > 0)
        {
            recommendations.Add("Fix critical dynamic analysis vulnerabilities");
        }
        
        if (penetrationTest.Summary.CriticalCount > 0)
        {
            recommendations.Add("Resolve critical penetration test findings");
        }
        
        recommendations.Add("Implement secure coding practices");
        recommendations.Add("Regular security testing and code reviews");
        recommendations.Add("Security training for development team");
        
        return string.Join(". ", recommendations);
    }
    
    private string GetReportStyles()
    {
        return @"
            body { font-family: Arial, sans-serif; margin: 20px; }
            header { background-color: #f0f0f0; padding: 20px; border-radius: 5px; }
            section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
            .critical { color: #d32f2f; font-weight: bold; }
            .high { color: #f57c00; font-weight: bold; }
            .medium { color: #fbc02d; font-weight: bold; }
            .low { color: #388e3c; font-weight: bold; }
            .info { color: #1976d2; font-weight: bold; }
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
        ";
    }
    
    private string GenerateExecutiveSummaryHtml(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        var totalVulnerabilities = staticAnalysis.Summary.TotalVulnerabilities +
                                 dynamicAnalysis.Summary.TotalVulnerabilities +
                                 penetrationTest.Summary.TotalVulnerabilities;
        
        return $"<p>Total vulnerabilities found: <strong>{totalVulnerabilities}</strong></p>" +
               $"<p>Static Analysis: {staticAnalysis.Summary.TotalVulnerabilities} vulnerabilities</p>" +
               $"<p>Dynamic Analysis: {dynamicAnalysis.Summary.TotalVulnerabilities} vulnerabilities</p>" +
               $"<p>Penetration Test: {penetrationTest.Summary.TotalVulnerabilities} vulnerabilities</p>";
    }
    
    private string GenerateStaticAnalysisHtml(ProjectSecurityAnalysisResult staticAnalysis)
    {
        var html = new StringBuilder();
        
        html.AppendLine($"<p>Total files analyzed: {staticAnalysis.Summary.TotalFiles}</p>");
        html.AppendLine($"<p>Total vulnerabilities: {staticAnalysis.Summary.TotalVulnerabilities}</p>");
        html.AppendLine("<table>");
        html.AppendLine("<tr><th>Severity</th><th>Count</th></tr>");
        html.AppendLine($"<tr><td class='critical'>Critical</td><td>{staticAnalysis.Summary.CriticalCount}</td></tr>");
        html.AppendLine($"<tr><td class='high'>High</td><td>{staticAnalysis.Summary.HighCount}</td></tr>");
        html.AppendLine($"<tr><td class='medium'>Medium</td><td>{staticAnalysis.Summary.MediumCount}</td></tr>");
        html.AppendLine($"<tr><td class='low'>Low</td><td>{staticAnalysis.Summary.LowCount}</td></tr>");
        html.AppendLine($"<tr><td class='info'>Info</td><td>{staticAnalysis.Summary.InfoCount}</td></tr>");
        html.AppendLine("</table>");
        
        return html.ToString();
    }
    
    private string GenerateDynamicAnalysisHtml(DynamicSecurityTestResult dynamicAnalysis)
    {
        var html = new StringBuilder();
        
        html.AppendLine($"<p>Total tests executed: {dynamicAnalysis.Summary.TotalTests}</p>");
        html.AppendLine($"<p>Total vulnerabilities: {dynamicAnalysis.Summary.TotalVulnerabilities}</p>");
        html.AppendLine("<table>");
        html.AppendLine("<tr><th>Severity</th><th>Count</th></tr>");
        html.AppendLine($"<tr><td class='critical'>Critical</td><td>{dynamicAnalysis.Summary.CriticalCount}</td></tr>");
        html.AppendLine($"<tr><td class='high'>High</td><td>{dynamicAnalysis.Summary.HighCount}</td></tr>");
        html.AppendLine($"<tr><td class='medium'>Medium</td><td>{dynamicAnalysis.Summary.MediumCount}</td></tr>");
        html.AppendLine($"<tr><td class='low'>Low</td><td>{dynamicAnalysis.Summary.LowCount}</td></tr>");
        html.AppendLine("</table>");
        
        return html.ToString();
    }
    
    private string GeneratePenetrationTestHtml(PenetrationTestResult penetrationTest)
    {
        var html = new StringBuilder();
        
        html.AppendLine($"<p>Total tests executed: {penetrationTest.Summary.TotalTests}</p>");
        html.AppendLine($"<p>Total vulnerabilities: {penetrationTest.Summary.TotalVulnerabilities}</p>");
        html.AppendLine("<table>");
        html.AppendLine("<tr><th>Severity</th><th>Count</th></tr>");
        html.AppendLine($"<tr><td class='critical'>Critical</td><td>{penetrationTest.Summary.CriticalCount}</td></tr>");
        html.AppendLine($"<tr><td class='high'>High</td><td>{penetrationTest.Summary.HighCount}</td></tr>");
        html.AppendLine($"<tr><td class='medium'>Medium</td><td>{penetrationTest.Summary.MediumCount}</td></tr>");
        html.AppendLine($"<tr><td class='low'>Low</td><td>{penetrationTest.Summary.LowCount}</td></tr>");
        html.AppendLine("</table>");
        
        return html.ToString();
    }
    
    private string GenerateRecommendationsHtml(
        ProjectSecurityAnalysisResult staticAnalysis,
        DynamicSecurityTestResult dynamicAnalysis,
        PenetrationTestResult penetrationTest)
    {
        var recommendations = new List<string>();
        
        if (staticAnalysis.Summary.CriticalCount > 0)
        {
            recommendations.Add("Address critical static analysis findings immediately");
        }
        
        if (dynamicAnalysis.Summary.CriticalCount > 0)
        {
            recommendations.Add("Fix critical dynamic analysis vulnerabilities");
        }
        
        if (penetrationTest.Summary.CriticalCount > 0)
        {
            recommendations.Add("Resolve critical penetration test findings");
        }
        
        recommendations.Add("Implement secure coding practices");
        recommendations.Add("Regular security testing and code reviews");
        recommendations.Add("Security training for development team");
        
        var html = new StringBuilder();
        html.AppendLine("<ul>");
        
        foreach (var recommendation in recommendations)
        {
            html.AppendLine($"<li>{recommendation}</li>");
        }
        
        html.AppendLine("</ul>");
        
        return html.ToString();
    }
}

// Modelo para reporte de vulnerabilidades
public class VulnerabilityReport
{
    public DateTime GeneratedAt { get; set; }
    public ProjectSecurityAnalysisResult StaticAnalysis { get; set; }
    public DynamicSecurityTestResult DynamicAnalysis { get; set; }
    public PenetrationTestResult PenetrationTest { get; set; }
    public string ExecutiveSummary { get; set; }
    public string Recommendations { get; set; }
}
```

## 游꿢 **Ejercicios Pr치cticos**

### **Ejercicio 1: Implementar SAST Personalizado**
```csharp
// Crear una regla de seguridad personalizada
public class CustomSecurityRule : ISecurityRule
{
    public async Task<List<SecurityVulnerability>> AnalyzeAsync(SyntaxTree syntaxTree, SyntaxNode root)
    {
        // Implementar an치lisis de seguridad personalizado
        // 1. Identificar patrones de c칩digo inseguro
        // 2. Generar vulnerabilidades
        // 3. Proporcionar recomendaciones
    }
}
```

### **Ejercicio 2: Implementar DAST Personalizado**
```csharp
// Crear una prueba de seguridad din치mica personalizada
public class CustomSecurityTest : ISecurityTest
{
    public async Task<SecurityTestResult> ExecuteAsync(Endpoint endpoint, HttpClient httpClient)
    {
        // Implementar prueba de seguridad din치mica personalizada
        // 1. Enviar payloads maliciosos
        // 2. Analizar respuestas
        // 3. Identificar vulnerabilidades
    }
}
```

## 游닇 **Resumen de la Clase**

### **Conceptos Clave Aprendidos:**
1. **Static Application Security Testing (SAST)**: An치lisis de c칩digo fuente
2. **Dynamic Application Security Testing (DAST)**: Pruebas en tiempo de ejecuci칩n
3. **Penetration Testing**: Pruebas de penetraci칩n automatizadas
4. **Vulnerability Reporting**: Generaci칩n de reportes de seguridad
5. **Security Rules**: Reglas personalizadas de seguridad
6. **Automated Testing**: Automatizaci칩n de pruebas de seguridad

### **Pr칩xima Clase:**
En la siguiente clase exploraremos **Security Monitoring y Incident Response**, incluyendo monitoreo de seguridad y respuesta a incidentes.

---

## 游댕 **Recursos Adicionales**

- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [SonarQube Security Rules](https://rules.sonarsource.com/csharp)
- [OWASP ZAP](https://owasp.org/www-project-zap/)
- [Burp Suite](https://portswigger.net/burp)
- [Nessus](https://www.tenable.com/products/nessus)
